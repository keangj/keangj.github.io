

## 节流

``` js
// 节流（一段时间执行一次之后，就不执行第二次）
 function throttle(fn, delay){
     let canUse = true
     return function(){
         if(canUse){
             fn.apply(this, arguments)
             canUse = false
             setTimeout(()=>canUse = true, delay)
         }
     }
 }

 const throttled = throttle(()=>console.log('hi'))
 throttled()
 throttled()


function throttle (fn, delay) {
  let timer = null
  return (...args) => {
    if (timer) return
    timer = setTimeout(() => {
      fn.call(undefined, ...args)
      timer = null
    }, delay)
  }
}
```







## 防抖

``` js
// 防抖（一段时间会等，然后带着一起做了）
 function debounce(fn, delay){
     let timerId = null
     return function(){
         const context = this
         if(timerId){window.clearTimeout(timerId)}
         timerId = setTimeout(()=>{
             fn.apply(context, arguments)
             timerId = null
         },delay)
     }
 }
 const debounced = debounce(()=>console.log('hi'))
 debounced()
 debounced()


function debounce (fn, delay) {
  let timer = null
  return (...args) => {
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      fn.call(undefined, ...args)
      timer = null
    }, delay)
  }
}
```



数组去重

``` js
// 计数排序
function uniq (arr) {
  const map = {}
  for (let i = 0; i < arr.length; i++) {
    const number = arr[i]
    if (!number ) continue
    if (number in map) continue
    map[number] = true
  }
  return Object.keys(map)
}

// map
function uniq (arr) {
  const map = new Map()
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i]
    if (!item) continue
    if (map.has(item)) continue
    map.set(item)
  }     
  return [...map.keys()]
}
```

深拷贝

``` js
function deepClone (source, cache) {
  if (!cache) { cache = new Map() }
  if (source instanceof Object) {
    if (cache.has(source)) { return cache.get(source) }
    let result = null
    if (source instanceof Function) {
      if (source.prtotype) {
        result = function () { return source.apply(this, arguments) }
      } else {
        result = (...args) => source.call(undefined, ...args)
      }
    } else if (source instanceof Array) {
        result = []
    } else if (source instanceof Date) {
        result = new Date(source - 0)
    } else if (source instanceof RegExp) {
        result = new RegExp(source.source, source.flags)
    } else {
        result = {}
    }
    cache.set(source, result)
    for (let key in source) {
      if (source.hasOwnProperty(key)) {
        result[key] = deepClone(source[key], cache)
      }
    }
    return result
  } else {
    return source
  }
}
```

